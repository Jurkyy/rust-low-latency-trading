//! Trading strategies for the trading client.
//!
//! This module provides two main trading strategies:
//!
//! - **Market Maker** (`market_maker`): Provides liquidity by quoting bid/ask
//!   around fair value with configurable spread and size parameters.
//!
//! - **Liquidity Taker** (`liquidity_taker`): Aggressively takes liquidity when
//!   trading signals exceed configurable thresholds.
//!
//! Both strategies consume `TickerFeatures` from the feature engine and generate
//! `OrderRequest` outputs that can be processed by the trade engine.

pub mod market_maker;
pub mod liquidity_taker;

pub use market_maker::{MarketMaker, MarketMakerConfig};
pub use liquidity_taker::{LiquidityTaker, LiquidityTakerConfig};

use common::{Price, Qty, Side, TickerId};

/// Represents an order request generated by a strategy.
///
/// This is a lightweight struct that contains all the information needed
/// to submit an order to the exchange via the order gateway.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct OrderRequest {
    /// The ticker to trade.
    pub ticker_id: TickerId,
    /// Buy or Sell.
    pub side: Side,
    /// Limit price for the order.
    pub price: Price,
    /// Quantity to trade.
    pub qty: Qty,
}

impl OrderRequest {
    /// Creates a new order request.
    #[inline]
    pub fn new(ticker_id: TickerId, side: Side, price: Price, qty: Qty) -> Self {
        Self {
            ticker_id,
            side,
            price,
            qty,
        }
    }

    /// Creates a buy order request.
    #[inline]
    pub fn buy(ticker_id: TickerId, price: Price, qty: Qty) -> Self {
        Self::new(ticker_id, Side::Buy, price, qty)
    }

    /// Creates a sell order request.
    #[inline]
    pub fn sell(ticker_id: TickerId, price: Price, qty: Qty) -> Self {
        Self::new(ticker_id, Side::Sell, price, qty)
    }
}

/// Represents a pair of quotes (bid and ask) for market making.
#[derive(Debug, Clone, Copy, Default)]
pub struct QuotePair {
    /// The bid (buy) quote, if any.
    pub bid: Option<OrderRequest>,
    /// The ask (sell) quote, if any.
    pub ask: Option<OrderRequest>,
}

impl QuotePair {
    /// Creates a new quote pair with both bid and ask.
    pub fn new(bid: OrderRequest, ask: OrderRequest) -> Self {
        Self {
            bid: Some(bid),
            ask: Some(ask),
        }
    }

    /// Creates an empty quote pair.
    pub fn empty() -> Self {
        Self {
            bid: None,
            ask: None,
        }
    }

    /// Creates a quote pair with only a bid.
    pub fn bid_only(bid: OrderRequest) -> Self {
        Self {
            bid: Some(bid),
            ask: None,
        }
    }

    /// Creates a quote pair with only an ask.
    pub fn ask_only(ask: OrderRequest) -> Self {
        Self {
            bid: None,
            ask: Some(ask),
        }
    }

    /// Returns true if both bid and ask quotes are present.
    #[inline]
    pub fn is_two_sided(&self) -> bool {
        self.bid.is_some() && self.ask.is_some()
    }

    /// Returns true if at least one quote is present.
    #[inline]
    pub fn has_quotes(&self) -> bool {
        self.bid.is_some() || self.ask.is_some()
    }
}

/// Result of a strategy decision - what action to take.
#[derive(Debug, Clone)]
pub enum StrategyAction {
    /// No action needed.
    None,
    /// Generate new quotes (for market making).
    Quote(QuotePair),
    /// Take liquidity aggressively.
    Take(OrderRequest),
    /// Cancel existing orders.
    CancelAll(TickerId),
}

impl StrategyAction {
    /// Returns true if this action requires sending orders.
    #[inline]
    pub fn requires_orders(&self) -> bool {
        matches!(self, StrategyAction::Quote(_) | StrategyAction::Take(_))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_order_request_new() {
        let req = OrderRequest::new(1, Side::Buy, 10000, 100);
        assert_eq!(req.ticker_id, 1);
        assert_eq!(req.side, Side::Buy);
        assert_eq!(req.price, 10000);
        assert_eq!(req.qty, 100);
    }

    #[test]
    fn test_order_request_buy_sell() {
        let buy = OrderRequest::buy(1, 10000, 100);
        assert_eq!(buy.side, Side::Buy);

        let sell = OrderRequest::sell(1, 10100, 50);
        assert_eq!(sell.side, Side::Sell);
    }

    #[test]
    fn test_quote_pair_new() {
        let bid = OrderRequest::buy(1, 10000, 100);
        let ask = OrderRequest::sell(1, 10100, 100);
        let pair = QuotePair::new(bid, ask);

        assert!(pair.is_two_sided());
        assert!(pair.has_quotes());
        assert_eq!(pair.bid.unwrap().price, 10000);
        assert_eq!(pair.ask.unwrap().price, 10100);
    }

    #[test]
    fn test_quote_pair_empty() {
        let pair = QuotePair::empty();
        assert!(!pair.is_two_sided());
        assert!(!pair.has_quotes());
    }

    #[test]
    fn test_quote_pair_one_sided() {
        let bid = OrderRequest::buy(1, 10000, 100);
        let bid_only = QuotePair::bid_only(bid);
        assert!(!bid_only.is_two_sided());
        assert!(bid_only.has_quotes());

        let ask = OrderRequest::sell(1, 10100, 100);
        let ask_only = QuotePair::ask_only(ask);
        assert!(!ask_only.is_two_sided());
        assert!(ask_only.has_quotes());
    }

    #[test]
    fn test_strategy_action_requires_orders() {
        assert!(!StrategyAction::None.requires_orders());
        assert!(!StrategyAction::CancelAll(1).requires_orders());

        let quote = QuotePair::empty();
        assert!(StrategyAction::Quote(quote).requires_orders());

        let take = OrderRequest::buy(1, 10000, 100);
        assert!(StrategyAction::Take(take).requires_orders());
    }
}
